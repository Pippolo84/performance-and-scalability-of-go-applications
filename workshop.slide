Performance and Scalability of Go Applications
24 Sep 2019
Tags: Go, performance, scalability

Fabio Falzoi
Senior Software Engineer @ Develer
fabio.falzoi84@gmail.com
https://github.com/Pippolo84
@Pippolo84

* Before starting

- check your Go environment compiling and running the "Hello World"
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello world!")
    }

- download the workshop material
    git clone git@github.com:Pippolo84/performance-and-scalability-of-go-applications.git

- peeking inside the solution folders is not allowed ;-)

* Introduction

* Big O notation in a nutshell

Adapted from [[https://en.wikipedia.org/wiki/Big_O_notation][Wikipedia]]

    Let f be a real valued function and g a real valued function. One writes:

    f(x) = O(g(x)) for x -> +inf
    
    if for all sufficiently large values of x, the absolute value of f(x) is at most a positive
    constant multiple of g(x).

    That is, f(x) = O(g(x)) if and only if there exists a positive real number M and
    a real number x0 such that

    abs(f(x)) <= Mg(x) for all x >= x0

* Time complexity examples

- _O(1)_ constant time (look-up table)
- _O(logn)_ logarithmic time (binary search)
- _O(n)_ linear time (linear search)
- _O(nlogn)_ linearithmic time (quick sort)
- _O(n^2)_ quadratic time (bubble sort)

* A taste of performance analysis

Try to complete the Isogram exercise!

Follow the instructions inside
    
    01-introduction/INSTRUCTIONS.md

Happy coding!

* Isogram solutions

1) Using a set

    - iterate over the string
    - for each rune: if it is already in the map, return false
    - return true

2) Using sorting

    - sort the string
    - check each pair of adjacent runes
    - if you find a pair of equal runes, return false, otherwise return true

3) Using linear searching

    - iterate over the string
    - for each rune, search for it in the remaining part of the string
    - if found, return false, otherwise, return true

*Quick-quiz*: can you guess the time complexity of each solution?

* Isogram solutions time complexities

1) Using a set: _O(n)_
2) Using sorting: _O(nlogn)_
3) Using linear searching: _O(n^2)_

* Let's benchmark them!

Inside the solution folder

    $ go test -run=^$ -bench=.
    goos: linux
    goarch: amd64
    pkg: performance-and-scalability-of-go-applications/01-introduction/solution
    BenchmarkIsIsogram/01-map-8               200000              8203 ns/op
    BenchmarkIsIsogram/02-sorting-8           300000              5534 ns/op
    BenchmarkIsIsogram/03-linear-search-8            1000000              1382 ns/op
    ...
    PASS
    ok      performance-and-scalability-of-go-applications/01-introduction/solution 6.295s 

Wait... What!?

* Map vs Sort vs Linear Search

.image img/RuneUniqueAll.svg

For #runes < 256 the linear search outperforms the other implementation

* Map vs Sort

.image img/RuneUniqueMapVsSort.svg

For #runes < 1024 the sort implementation is still faster than the map

* A closer look to the map data type

There are no generics in Go 1.13

The compiler rewrites lookups, insertion and removal into functions calls to the runtime package

    v := found[r]
    func mapaccess1_*(t *maptype, h *hmap, key uint32) unsafe.Pointer

    found[r] = true
    func mapassign_*(t *maptype, h *hmap, key uint32) unsafe.Pointer

- hmap implements the generic map logic
- maptype is unique to the specific map type declared and contains key and value type descriptors

* A closer look to the map data type

    go tool compile -S isogram.go

    0x00df 00223 (isogram.go:18)    MOVL    AX, "".r+40(SP)                 ;; key loaded in AX
    0x00e3 00227 (isogram.go:19)    LEAQ    type.map[int32]bool(SB), CX     ;; t *maptype loaded in CX
    0x00ea 00234 (isogram.go:19)    MOVQ    CX, (SP)                        ;; t *maptype on the stack
    0x00ee 00238 (isogram.go:19)    LEAQ    ""..autotmp_8+112(SP), DX       ;; h *hmap loaded in DX
    0x00f3 00243 (isogram.go:19)    MOVQ    DX, 8(SP)                       ;; h *hmap on the stack
    0x00f8 00248 (isogram.go:19)    MOVL    AX, 16(SP)                      ;; key on the stack

    ;; runtime.mapaccess1_fast32(t, h, key)
    0x00fc 00252 (isogram.go:19)    CALL    runtime.mapaccess1_fast32(SB)

    0x010b 00267 (isogram.go:23)    LEAQ    type.map[int32]bool(SB), AX     ;; t *maptype loaded in CX
    0x0112 00274 (isogram.go:23)    MOVQ    AX, (SP)                        ;; t *maptype on the stack
    0x0116 00278 (isogram.go:23)    LEAQ    ""..autotmp_8+112(SP), CX       ;; h *hmap loaded in DX
    0x011b 00283 (isogram.go:23)    MOVQ    CX, 8(SP)                       ;; h *hmap on the stack
    0x0120 00288 (isogram.go:23)    MOVL    "".r+40(SP), DX                 ;; key loaded in DX
    0x0124 00292 (isogram.go:23)    MOVL    DX, 16(SP)                      ;; key on the stack

    ;; runtime.mapassign_fast32(t, h, k)
    0x0128 00296 (isogram.go:23)    CALL    runtime.mapassign_fast32(SB)

* A closer look to sort.Sort

from sort.go:

    func quickSort(data Interface, a, b, maxDepth int) {
        for b-a > 12 { // Use ShellSort for slices <= 12 elements
            ...
        }
        if b-a > 1 {
            // Do ShellSort pass with gap 6
            // It could be written in this simplified form cause b-a <= 12
            for i := a + 6; i < b; i++ {
                if data.Less(i, i-6) {
                    data.Swap(i, i-6)
                }
            }
            insertionSort(data, a, b)
        }
    }

For small slices, the standard library doesn't even use Quicksort!

* A closer look to strings.ContainsRune

from indexbyte_amd64.s:

    sseloop:
	// Move the next 16-byte chunk of the data into X1.
	MOVOU	(DI), X1
	// Compare bytes in X0 to X1.
	PCMPEQB	X0, X1
	// Take the top bit of each byte in X1 and put the result in DX.
	PMOVMSKB X1, DX
	// Find first set bit, if any.
	BSFL	DX, DX
	JNZ	ssesuccess
	// Advance to next block.
	ADDQ	$16, DI

Search is done using SIMD instructions

* Can we do even better?

Consider the test cases, we can see that:
- all runes are in the ASCII set
- we are only interested in the 26 alphabetical letters

* Array as a map

    func IsIsogram(s string) bool {
        foundRune := [26]bool{} //'a' to 'z'

        for _, r := range s {
            if !unicode.IsLetter(r) {
                continue
            }

            // convert the rune to lowercase to index foundRune
            r = unicode.ToLower(r)
            i := r - 'a'

            if foundRune[i] == true {
                return false
            }
            foundRune[i] = true
        }

        return true
    }

* Benchmarks

    BenchmarkIsIsogram/01-map-8               200000              8203 ns/op
    BenchmarkIsIsogram/02-sorting-8           300000              5534 ns/op
    BenchmarkIsIsogram/03-linear-search-8            1000000              1382 ns/op
    BenchmarkIsIsogram/04-bool-array-8               3000000               525 ns/op

* Pitfalls of the time complexity model

Constant factors are important. What are they determined by?

- memory access pattern
- algorithms implemented in hardware
- ...

* Take home message

Time complexity with Big O notation tells us just a part of the story!

If we want to get the most ouf of our applications we need to:

- understand our hardware, the Go runtime internals and their interactions
- learn to profile and benchmark our application with meaningful dataset

That's why the rest of this workshop is dedicated to that! ;-)

* Roadmap

- Modern CPU architecture
- Benchmarking
- Profiling
- The Go scheduler
- The Go memory allocator & garbage collector

* Modern CPU architecture

* Benchmarking

* A stable environment

When benchmarking, try to make your environment as stable as possible:

- avoid shared hardware, virtual machines and shared cloud hosting
- close all resource hungry applications so that CPU utilization is lower than ~5%

Specifically

- do not browse the Web
- do not check emails
- do not use your editor to write stuff

and above all...

* A stable environment

- resist the urge to answer on Slack using Giphy

.image https://media.giphy.com/media/n2IekUAIvjz2w/giphy.gif

*Quick-quiz*: try to guess the increase in CPU utilization due to this GIF, then measure it with top

* Advanced HW tweaking to improve stability

- disable Turbo Boost

    # Intel
    echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo
    # AMD
    echo 0 > /sys/devices/system/cpu/cpufreq/boost

- Set scaling_governor to "performance"

    echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    echo performance > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
    echo performance > /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
    ...

- Set process priority

    nice -n 10 ./isogram.bench -test.run=^$ -test.bench=. -test.benchmem

More on this [[https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux][here]]

* Expensive HW tweaking to improve stability

Buy dedicated HW to run your benchmarks

* Benchmarking for humans

- create a test executable to do a before/after comparison
- use [[https://godoc.org/golang.org/x/perf/cmd/benchstat][benchstat]]

more on this later!

* Go benchmark tooling

Very similar to testing

    func BenchmarkIsIsogram(b *testing.B) {
        for i := 0; i < b.N; i++ {
            IsIsogram("input test string")
        }
    }

You can execute them with:

    go test -bench=.

This will first run the tests, and then the benchmarks

* Go benchmarking output

Sample output produced

    goos: linux
    goarch: amd64
    pkg: path/to/package
    BenchmarkName-8  100000  1859 ns/op  57 B/op
    PASS
    ok  path/to/package   2.042s

A line starting with the BenchmarkName followed by the number of cores (GOMAXPROCS) available, then the number of times (100000) the benchmark was run.

The next two numbers indicate:

- the time it took to execute the benchmark, in ns/op (nanoseconds per operation)
- the memory usage, in B/op (bytes of memory allocated per operation)

lower is better.

* How benchmarks work

Each benchmark function is repeatedly called with different value for b.N, the number of iterations the benchmark should run for.

b.N starts at 1, if the benchmark function completes in less than 1 second, then b.N is increased and the benchmark function is called again.

b.N increases in a sequence adapted by the benchmark framework.

    BenchmarkIsIsogram/01-map-8               200000              8203 ns/op
    BenchmarkIsIsogram/02-sorting-8           300000              5534 ns/op
    BenchmarkIsIsogram/03-linear-search-8            1000000              1382 ns/op
    BenchmarkIsIsogram/04-bool-array-8               3000000               525 ns/op

*Quick-quiz*: why each benchmark run for different number of iterations (200000, 300000, 1000000 and 3000000)?

* Benchmark option -cpu

Change the value of CPUs used

    -cpu

Example

    go test -v -run=^$ -bench=. -cpu=1,4,8

    goos: linux
    goarch: amd64
    pkg: performance-and-scalability-of-go-applications/01-introduction/isogram/solution
    BenchmarkIsIsogram/01-map           	  200000	      6886 ns/op
    BenchmarkIsIsogram/01-map-4         	  200000	      7246 ns/op
    BenchmarkIsIsogram/01-map-8         	  200000	      7951 ns/op
    ...
    PASS
    ok  	performance-and-scalability-of-go-applications/01-introduction/isogram/solution	19.518s

* Benchmark option -benchtime

By default, Go will run the benchmark, increasing b.N, until it takes more than 1s to complete.

You can change this behaviour using -benchtime option

Examples

- run the benchmark until it hits the 10s threshold

    go test -v -run=^$ -bench=. -benchtime=10s

- make exactly 100 iterations

    go test -v -run=^$ -bench=. -benchtime=100x

* Benchmark option -count

By default, each benchmark is repeated just once.

You can change this behaviour using -count option

Example

- run each benchmark twice

    go test -v -run=^$ -bench=. -count=2

* benchstat



* Avoid benchmark setup cost

* Benchmarking allocations

* Benchmarking pitfalls

Consider the following benchmark

    func NaturalNumbersSum(n int) int {
        return n * (n + 1) / 2
    }

    func BenchmarkNaturalNumbersSum(b *testing.B) {
        for i := 0; i < b.N; i++ {
            NaturalNumbersSum(i)
        }
    }

And its results

    ...
    BenchmarkNaturalNumbersSum-8    2000000000               0.30 ns/op
    PASS

0.30 ns/op is the time of a single clock cycle...

* Benchmarking pitfalls

Using

    go test -v -run=^$ -bench=. -gcflags="-m"

We can see that the call to NaturalNumbersSum is inlined by the compiler...

    ...
    ./gauss.go:3:6: can inline NaturalNumbersSum
    ./gauss_test.go:7:20: inlining call to NaturalNumbersSum
    ...

* Benchmarking pitfalls

And since the body of the function has no side effects, it is optimized away by the CPU!

    "".BenchmarkNaturalNumbersSum STEXT nosplit size=23 args=0x8 locals=0x0
        0x0000 00000 (gauss_test.go:5)       TEXT    "".BenchmarkNaturalNumbersSum(SB), NOSPLIT|ABIInternal, $0-8
        ...
        0x0000 00000 (gauss_test.go:6)       MOVQ    "".b+8(SP), AX
        0x0005 00005 (gauss_test.go:6)       XORL    CX, CX
        0x0007 00007 (gauss_test.go:6)       JMP     13
        0x0009 00009 (gauss_test.go:6)       INCQ    CX
        0x000c 00012 (gauss_test.go:7)       XCHGL   AX, AX
        0x000d 00013 (gauss_test.go:6)       CMPQ    264(AX), CX
        0x0014 00020 (gauss_test.go:6)       JGT     9
        ...
        0x0016 00022 (<unknown line number>)    RET

* Fixing the benchmark

Force the body of the for loop to produce effects visible outside the loop itself

    var result int

    func BenchmarkNaturalNumbersSum(b *testing.B) {
        var r int
        for i := 0; i < b.N; i++ {
            r = NaturalNumbersSum(i)
        }
        result = r
    }

inspired by [[https://github.com/golang/go/issues/14813#issue-140603392][issue #14183]]

* Fixing the benchmark

    "".BenchmarkNaturalNumbersSum STEXT nosplit size=54 args=0x8 locals=0x0
            0x0000 00000 (gauss_test.go:7)       TEXT    "".BenchmarkNaturalNumbersSum(SB), NOSPLIT|ABIIn
    ternal, $0-8
        ...
            0x0000 00000 (gauss_test.go:10)      MOVQ    "".b+8(SP), AX
            0x0005 00005 (gauss_test.go:10)      XORL    CX, CX
            0x0007 00007 (gauss_test.go:10)      XORL    DX, DX
            0x0009 00009 (gauss_test.go:10)      JMP     37
            0x000b 00011 (gauss_test.go:11)      XCHGL   AX, AX
            0x000c 00012 (gauss.go:4)    LEAQ    1(CX), BX
            0x0010 00016 (gauss.go:4)    IMULQ   BX, CX
            0x0014 00020 (gauss.go:4)    MOVQ    CX, SI
            0x0017 00023 (gauss.go:4)    SHRQ    $63, CX
            0x001b 00027 (gauss.go:4)    LEAQ    (CX)(SI*1), DX
            0x001f 00031 (gauss.go:4)    SARQ    $1, DX
            0x0022 00034 (gauss_test.go:10)      MOVQ    BX, CX
            0x0025 00037 (gauss_test.go:10)      CMPQ    264(AX), CX
            0x002c 00044 (gauss_test.go:10)      JGT     11
        ...
            0x002e 00046 (gauss_test.go:14)      MOVQ    DX, "".result(SB)
            0x0035 00053 (gauss_test.go:15)      RET

* Insert and Remove exercise

Follow the instructions inside

    03-benchmarking/INSTRUCTIONS.md

Happy coding!

* Insert and Remove exercise solution

.image img/InsertRemove.svg

Predictability of memory access makes slice the winner!

* Insert and Remove exercise solution

Useful options:

- -count
- -benchtime

to check benchmark stability and get more meaningful results for longer execution test cases

* Profiling

* The Go scheduler

* The Go memory allocator & garbage collector
