Performance and Scalability of Go Applications
24 Sep 2019
Tags: Go, performance, scalability

Fabio Falzoi
Senior Software Engineer @ Develer
fabio.falzoi84@gmail.com
https://github.com/Pippolo84
@Pippolo84


* Before starting

- check your Go environment compiling and running the "Hello World"
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello world!")
    }

- download the workshop material
    git clone git@github.com:Pippolo84/performance-and-scalability-of-go-applications.git

- peeking inside the solution folders is not allowed ;-)

* Big O notation in a nutshell

.link https://en.wikipedia.org/wiki/Big_O_notation Definition

    Let f be a real valued function and g a real valued function. One writes:

    f(x) = O(g(x)) for x -> +inf
    
    if for all sufficiently large values of x, the absolute value of f(x) is at most a positive
    constant multiple of g(x).

    That is, f(x) = O(g(x)) if and only if there exists a positive real number M and
    a real number x0 such that

    abs(f(x)) <= Mg(x) for all x >= x0

* Time complexity examples

- _O(1)_ constant time (look-up table)
- _O(logn)_ logarithmic time (binary search)
- _O(n)_ linear time (linear search)
- _O(nlogn)_ linearithmic time (quick sort)
- _O(n^2)_ quadratic time (bubble sort)

* A taste of performance analysis

Try to complete the Isogram exercise!

Follow the instructions inside
    
    01-introduction/INSTRUCTIONS.md

Happy coding!

* Isogram solutions

1) Using a set

    - iterate over the string
    - for each rune: if it is already in the map, return false
    - return true

2) Using sorting

    - sort the string
    - check each pair of adjacent runes
    - if you find a pair of equal runes, return false, otherwise return true

3) Using linear searching

    - iterate over the string
    - for each rune, search for it in the remaining part of the string
    - if found, return false, otherwise, return true

*Quick-quiz*: can you guess the time complexity of each solution?

* Isogram solutions time complexities

1) Using a set: _O(n)_
2) Using sorting: _O(nlogn)_
3) Using linear searching: _O(n^2)_

* Let's benchmark them!

Inside the solution folder

    $ go test -run=^$ -bench=.
    goos: linux
    goarch: amd64
    pkg: performance-and-scalability-of-go-applications/01-introduction/solution
    BenchmarkIsIsogram/01-map-8               200000              8203 ns/op
    BenchmarkIsIsogram/02-sorting-8           300000              5534 ns/op
    BenchmarkIsIsogram/03-linear-search-8            1000000              1382 ns/op
    ...
    PASS
    ok      performance-and-scalability-of-go-applications/01-introduction/solution 6.295s 

Wait... What!?

* Map vs Sort vs Linear Search

.image img/RuneUniqueAll.svg

For #runes < 256 the linear search outperforms the other implementation

* Map vs Sort

.image img/RuneUniqueMapVsSort.svg

For #runes < 1024 the sort implementation is still faster than the map

* A closer look to the map data type

TODO: map implementation, see:
- https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics
- https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html (OLDER!!!)

* A closer look to sort.Sort

from sort.go:

    func quickSort(data Interface, a, b, maxDepth int) {
        for b-a > 12 { // Use ShellSort for slices <= 12 elements
            ...
        }
        if b-a > 1 {
            // Do ShellSort pass with gap 6
            // It could be written in this simplified form cause b-a <= 12
            for i := a + 6; i < b; i++ {
                if data.Less(i, i-6) {
                    data.Swap(i, i-6)
                }
            }
            insertionSort(data, a, b)
        }
    }

For small slices, the standard library doesn't even use Quicksort

* A closer look to strings.ContainsRune

from indexbyte_amd64.s:

    sseloop:
	// Move the next 16-byte chunk of the data into X1.
	MOVOU	(DI), X1
	// Compare bytes in X0 to X1.
	PCMPEQB	X0, X1
	// Take the top bit of each byte in X1 and put the result in DX.
	PMOVMSKB X1, DX
	// Find first set bit, if any.
	BSFL	DX, DX
	JNZ	ssesuccess
	// Advance to next block.
	ADDQ	$16, DI

Search is done using SIMD instructions

* Can we do even better?

Consider the test cases, we can see that:
- all runes are in the ASCII set
- we are only interested in the 26 alphabetical letters

* Array as a map

    func IsIsogram(s string) bool {
        foundRune := [26]bool{} //'a' to 'z'

        for _, r := range s {
            if !unicode.IsLetter(r) {
                continue
            }

            // convert the rune to lowercase to index foundRune
            r = unicode.ToLower(r)
            i := r - 'a'

            if foundRune[i] == true {
                return false
            }
            foundRune[i] = true
        }

        return true
    }

* Benchmarks

    BenchmarkIsIsogram/01-map-8               200000              8203 ns/op
    BenchmarkIsIsogram/02-sorting-8           300000              5534 ns/op
    BenchmarkIsIsogram/03-linear-search-8            1000000              1382 ns/op
    BenchmarkIsIsogram/04-bool-array-8               3000000               525 ns/op

* Pitfalls of the time complexity model

Constant factors are important. What are they determined by?

- memory access pattern
- algorithms implemented in hardware
- ...

* Take home message

Time complexity with Big O notation can be misleading if applied blindly

If we want to get the most ouf of our applications we need to:

- understand our hardware, the Go runtime and their interactions
- learn to profile and benchmark our application with meaningful dataset

That's why the rest of this workshop is dedicated to that! ;-)

* Roadmap

- Modern CPU architecture
- Benchmarking
- Profiling
- The Go scheduler
- The Go memory allocator & garbage collector